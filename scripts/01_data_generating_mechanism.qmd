
This qmd houses the data generating mechanism used for our simulation study
This will involve various functions to make things run smoothly in `04 - simulation study`
The philosophy over this project is that it has a lot of moving parts, so breaking things down to simpler problems is the name of the game

Before we start, we will define some values we will use for test cases throughout the study.
*These must be run for any test cases to work*. However, ONLY this needs to be run for test cases

```{r}
set.seed(625)

my_sample <- 1000
weak_effects <- c(logit(0.1), log(1.1), log(0.7), log(0.85))
strong_effects <- c(logit(0.1), log(1.5), log(0.7), log(0.85))
```

*This is the value of the max*

```{r}
q_999999 <- get_mixture_quantile(0.999999)
```

*These are the formulas for use in logistic regression for our simulation study*

```{r}
#in general, to check the true logistic regression for the data before missingness, we need this
formula_biomarker <- "outcome ~ biomarker + confounder + predictor"
formula_biomarker_MCAR <- "outcome ~ biomarker_MCAR + confounder + predictor"
formula_biomarker_MAR <- "outcome ~ biomarker_MAR + confounder + predictor"
```

# `data_generator` is a function that generates our data, full stop. Nothing too fancy
>> Any modifications to the DGM will need to happen in this function, such as changing probabilities or sd
- sample_size is the sample size of the data
- coefficient_vector are the coefficients that we use to generate relationships between variables
>> That means we need to pass in a vector of size 4, which is specific to our study

```{r}
data_generator <- function(sample_size, coefficient_vector) {
  
  # Extract coefficients from the coefficient vector *b*
  b_0 <- coefficient_vector[1]
  b_1 <- coefficient_vector[2]
  b_2 <- coefficient_vector[3]
  b_3 <- coefficient_vector[4]
  
  # Generate values from distributions
  confounder <- rbinom(sample_size, size = 1, prob = 0.4) #prob of success is 0.4
  predictor <- rnorm(sample_size, mean = 0, sd = 1) #this is our continuous predictor
  biomarker <- rchisq(sample_size, df = 5 + 3*confounder) #if B = 1, X ~ chisq(8). else, X ~ chisq(5)
  
  # Generate the outcome
  outcome <- plogis(b_0 + b_1*biomarker + b_2*confounder + b_3*predictor) 
  outcome_binary <- rbinom(sample_size, size = 1, prob = outcome)
  
  # Into the dataframe
  my_data <- data.frame(
      confounder = confounder,
      predictor = predictor,
      biomarker = biomarker,
      outcome = outcome_binary
    )

  # Get our data
  return(my_data)
}
```

Test case: make sure that the data generates correctly, as well as get our coefficients

> Case 1: Success

```{r, eval=FALSE}
# Generate data
weak_effects_data <- data_generator(my_sample, weak_effects)

# Run LOGISTIC regression: isn't good...
glm(as.formula(formula_biomarker),
    data = weak_effects_data,
    family = "binomial") |>
  tbl_regression(exponentiate = TRUE)
```

> Case 2: Success

```{r, eval=FALSE}
# Generate data
strong_effects_data <- data_generator(my_sample, strong_effects)

# Run LOGISTIC regression
glm(as.formula(formula_biomarker),
    data = strong_effects_data,
    family = "binomial") |>
  tbl_regression(exponentiate = TRUE)
```

# `missing_generator` is a function that induces missingness from a given dataset generated by `data_generator`
It creates two variants of the `biomarker` variable
- biomarker_MAR: biomarker missing at random
- biomarker_MCAR: biomarker missing completely at random
- It also adds a row index, which will be useful later

*MAR is not implemented

```{r}
missing_generator <- function(my_data, missing_prop_for_MCAR) {

  # Add biomarker variants to induce missingness
  my_data <- my_data |>
    mutate(biomarker_MCAR = biomarker,
           biomarker_MAR = biomarker)
  
  # MCAR
  my_data <- missMethods::delete_MCAR(my_data,  #name of data
                                      missing_prop_for_MCAR,  #proportion of data you want missing
                                      "biomarker_MCAR") #name of variable you want to do this
  
  # MAR:
  
  
  # Add a row index 
  my_data <- my_data |>
    mutate(row_index = row_number())
  
  return(my_data)
}
```

> Case 1: Success

```{r, eval=FALSE}
weak_effects_data <- data_generator(my_sample, weak_effects)

missing_test_case <- missing_generator(weak_effects_data, 0.30) |>
  dplyr::select(biomarker_MCAR)

#should be 300
sum(is.na(missing_test_case$biomarker_MCAR))
rm(missing_test_case)
```

Recall that from `00`, we have `log_quant_transform`, which transforms the data based on the formula. 
We will show a test case and an example implementation, with a check being the inverse: `inv_log_quant_transform`

> Test case: Within the margin of error!

```{r, eval=FALSE}
weak_effects_data <- data_generator(my_sample, weak_effects)

weak_effects_data |>
  mutate(biomarker_transformed = sapply(biomarker, log_quant_transform,
                                        min = 0, max = q_999999)) |>
  mutate(biomarker_untransformed = sapply(biomarker_transformed, inv_log_quant_transform,
                                          min = 0, max = q_999999)) |>
  mutate(diff = biomarker - biomarker_untransformed) |> # see how close the original and untransformed vals are
  dplyr::select(diff) #look into it.
```

# `data_generating_mechanism` is the most important function here. It will generate our data with missingness and transformations. This also includes the implementation of `log_quant_transform` from `00`.

```{r}
data_generating_mechanism <- function(my_sample, beta_coefficients, prop_missing_MCAR,
                                      min_val = 0, max_val) {
  # Generate the data
  my_data <- data_generator(my_sample, beta_coefficients)
  
  # Induce MCAR and MAR missingness
  my_data <- missing_generator(my_data, prop_missing_MCAR)
  
  # Apply log transform to the biomarker data
  # As a caveat, I don't know if this is the best way to go about it
  my_data <- my_data |>
    mutate(biomarker_transformed = sapply(biomarker, log_quant_transform, #3 mutates for organization only
                                          min = min_val, max = max_val)) |> 
    mutate(biomarker_MCAR_transformed = sapply(biomarker_MCAR, log_quant_transform,
                                               min = min_val, max = max_val)) |>
    mutate(biomarker_MAR_transformed = sapply(biomarker_MAR, log_quant_transform,
                                              min = min_val, max = max_val)) 

  return(my_data)
}
```

> Case 1: Both full data and MCAR should yield unbiased results, but MCAR should have higher SE in estimate!

```{r, eval=FALSE}
# Generate data!
DGM_weak <- data_generating_mechanism(my_sample = my_sample,
                                      beta_coefficients = weak_effects,
                                      prop_missing_MCAR = 0.3,
                                      min_val = 0,
                                      max_val = q_999999)

# With biomarker data
summary(glm(as.formula(formula_biomarker), 
            data = DGM_weak,
            family = "binomial"))

# With MCAR biomarker data: 95% CI will be wider
summary(glm(as.formula(formula_biomarker), 
            data = DGM_weak,
            family = "binomial")) 
```

> Case 2: We're good to go!

```{r, eval=FALSE}
# Generate data!
DGM_strong <- data_generating_mechanism(my_sample = my_sample,
                                        beta_coefficients = weak_effects,
                                        prop_missing_MCAR = 0.3,
                                        min_val = 0,
                                        max_val = q_999999)

# With biomarker data
glm(as.formula(formula_biomarker), 
    data = DGM_strong,
    family = "binomial") |>
  broom::tidy()

# With MCAR biomarker data: 95% CI will be wider
glm(as.formula(formula_biomarker), 
    data = DGM_strong,
    family = "binomial") |>
  broom::tidy()
```

# Visualization for example: Just in case we need a visual of the distribution (AI generated)

```{r}
DGM_weak <- data_generating_mechanism(my_sample = my_sample,
                                      beta_coefficients = weak_effects,
                                      prop_missing_MCAR = 0.3,
                                      min_val = 0,
                                      max_val = q_999999)

#this is just some chatgpt code for a quick check
DGM_weak$confounder <- factor(DGM_weak$confounder, levels = c(0, 1), labels = c("Confounder = 0", "Confounder = 1"))

# Create the plot with overlaid density curves
ggplot(data = DGM_weak, aes(x = biomarker, fill = confounder, color = confounder)) +
  geom_density(alpha = 0.5) + 
  labs(title = "Biomarker Distribution by Confounder",
       x = "Biomarker",
       y = "Density") +
  scale_fill_manual(values = c("skyblue", "orange")) +  # Custom colors for filling
  scale_color_manual(values = c("blue", "red"))        # Custom border colors
```

# Remove, including all objects made from test cases

```{r}
rm(my_sample)

# weak
rm(weak_effects)
rm(weak_effects_data)
rm(DGM_weak)

# strong
rm(strong_effects)
rm(strong_effects_data)
rm(DGM_strong)
```